"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
 Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть); проанализировать 3 варианта и выбрать оптимальный;
c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
d. написать общий вывод: какой из трёх вариантов лучше и почему.

Для анализа выбрана задача 2.3:
Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
Например, если введено число 3486, надо вывести 6843.

Вывод
Было проанализировано 3 различных варианта решения задачи:
1)  Через цикл while, в котором на каждой итерации отделяется последний элемент и
    по формуле преобразуется цифру старшего разряда развернутого числа. Данный вариант предполагает использование
    только 2 чисел типа INT;
2)  Через цикл while, в котором на каждой итерации отделяется последний элемент, но в отличии от 1го варианта, этот
    элемент записывается в список num_list. Конечный резльтат получается принтом списка без переноса строки.
    Данный вариант предполагает использование одного списка и одногоцелого числа типа INT;
3)  Через преобразование начального числа в строку. Конечный результат получается принтом каждого символа строки
    поэлементно в обратном порядке. Данный вариант предполагает использование двух переменных типа STR и
    одного числа типа INT

Решение задачи проведено для нескольких вариантов начального числа, а именно для степеней числа 2 в диапазоне
от 2 до 100. Это сделано, чтобы проверить как изменяется потребеление памяти при росте начального числа.
В приложении есть график mem.png, на котором показана динамика изменения потребялемой памяти. По графику видно,
что самым "тяжелым" сначала был вариант 3 (зеленая линия), но примерно после числа 16000 вариант 2 обогнал вариант 3.
Это вызвано разной схемой выделения памяти для строк и списков. Самым "легковесным" получился вариант 1, так как
итерируемые типы данных в этом варианте не используются.

Вычисления проводились в IDE PyCharm 2020.2 CE.
Параметры системы:
3.8.1 (default, Feb  4 2020, 06:12:21)
[GCC 6.3.0 20170516] linux
Значения потребляемой памяти для каждого варианта при минимальном и максимальном начальном числах:
Вариант 1: min: 52 max: 64
Вариант 2: min: 112 max: 360
Вариант 3: min: 128 max: 198
"""
import sys

print(sys.version, sys.platform)

for k in range(100):
    num0 = 2 ** k
    print(f'Начальное число: {num0}')

    # Вариант 1
    num = num0
    num_rev = 0
    while num > 0:
        num_rev = 10 * num_rev + num % 10
        num //= 10
    # print(f'Развернутое число 1: {num_rev}')
    print(f'Потребляемая память в варианте 1: {sys.getsizeof(num) + sys.getsizeof(num_rev)}')

    # Вариант 2
    num = num0
    num_list = []
    while num > 0:
        num_list.append((num % 10))
        num //= 10
    # print(f'Развернутое число 2: ', end='')
    # for i in num_list:
    #     print(i, end='')
    # print()
    print(f'Потребляемая память в варианте 2: {sys.getsizeof(num) + sys.getsizeof(num_list)}')

    # Вариант 3
    num = num0
    s = str(num)
    s_r = ''
    for i in s[::-1]:
        s_r += i
    # print(f'Развернутое число 3: {s_r}')
    print(f'Потребляемая память в варианте 3: {sys.getsizeof(num) + sys.getsizeof(s) + sys.getsizeof(s_r)}')
